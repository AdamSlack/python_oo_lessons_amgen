---
title: "Object Oriented Programming With R"
subtitle: "A walkthrough from Procedural to OOP"
author: "Adam Slack"
date: "2017-6-16"
output: ioslides_presentation
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

## What is Object Oriented Programming?

- Object Oriented Programming (OOP) is a programming paradigm

- Involves the grouping of data with functions
    + These functions are used to apply changes to the contained data

- A collection of Data and Functions is called a class

- A Class is a blue print, from which instances of an object can be made

## Pros and Cons of OOP

Like all programming methodologies, there are upsides and downsides

Pros                                | Cons
------------------------------------|--------------------------
Scalable and Manageable Code bases  | Can be time consuming to design and produce
Less Code Redundancy                | Not always worth the effor for small projects
Portable and Re-usable code         |
Protects data from unwanted changes |

## Functionality vs Data
* Think about a program that involves cars
    + What can a car do? (The functionality)
    + What information you can record about a car? (The data)
  
Functionality       | Recordable Information
--------------------| ----------------------
Refuel              | Fuel
Drive               | Max Speed
Check fuel level    | Current Speed
check current speed | Colour

## Where does this fit in with code?

The information and functionality of a car in your program is specified inside of a class

A Class is composed of two sections

* Methods: 
    + What can the object do?
* Attributes:
    + what information is stored with the object?
    
Each Class can be used to instantiate objects

## A Class vs Objects

- If a class is a blueprint, an object is a physical instance of it

- A class can be used to create as many instances as you like
    - Same functionality
    - Same Data members
    - Different values for the data.

- Think of 3 different cars
    + Fiat Punto, Volkswagen Golf', Honda Jazz

- Each instance is a car
    + Same functionality
    + Same information can be recorded
    + At anyone time each car will have different values
    
## Standard R procedural Code
```{r echo = FALSE, results='hide',warning=FALSE,message=FALSE,error=FALSE}
# 
# R demonstration of Standard Procedural code.
# 

invisible(library(ggplot2))
invisible(library(reshape2))
```

```{r echo = TRUE}
cars <- c('Punto', 'Golf', 'Jazz')
colour <- c('beige', 'gold', 'neon pink')
fuel <- c(100,100,100) # inital percent of the fuel tank that is full
ppm <- c(10,20,5) # percent per mile fuel usage

remaining <- c() # what percentage of the fuel tank remains
miles <- 3 # how many miles do you plan to travel

for (i in 1:length(fuel)) { # calculate the new fuel tank values
  remaining <- c(remaining, (fuel[i] - (ppm[i]*3)))
}

car_frame <- data.frame(cars, fuel, remaining) # create a data frame
car_frame.m <- melt(car_frame, id.vars='cars') # melt the data frame for plotting

carplot <- ggplot(car_frame.m, aes(cars, value)) +   
  geom_bar(aes(fill = variable), position = "dodge", stat="identity")

```
## The resulting plot
```{r echo = FALSE, fig.keep=carplot}
carplot
```

## Adding Some functions
- The previous code can be improved by adding some functions.

- That way we can repeat what we did by calling the functions.

- We don't need to copy, paste and change the code that way.

## Drive Car
1. For the amount of time specified in distance
2. Calculate the change in fuel level
    - If the fuel goes below 0% dont record the change
3. Return the changes in fuel usage

```{r echo = TRUE}
drive_car <- function(starting_tank, ppm, distance) {
  tank_changes = c() # track the fuel usage using what % remains
  for(i in 0:distance) {
    new_tank <- starting_tank - (ppm * i)
    if(new_tank >= 0) {
      tank_changes <- c(tank_changes, new_tank) # only spend fuel if there was fuel to spend.
    }
  }
  return(tank_changes) # return the fuel usage
}

```

## Refuel Car
1. Record the amount of fuel added 
2. Cap the fuel level at 100%
3. Return the vector of fuel level changes

```{r echo = TRUE}
# creating a function to refuel a car
refuel_car <- function(tank_changes, tank_percentage) {
  new_tank <- tank_changes[length(tank_changes)] + tank_percentage
  if(new_tank > 100) {
    new_tank <- 100 # cant have more than a 100% full tank.
  }
  return(c(tank_changes, new_tank))
}

```
## Some data oriented functions
- Some functions will handle more abstract (or data oriented) aspects

- Padding of vectors in a collection such that they have equal length

- the construction of a dataframe so that plotting can be performed

## Pad Lengths
1. get the length of the longest vector
2. set the lengths of each vector to be that length
```{r echo=TRUE}
pad_lengths <- function(...) {
  arguments <- list(...)
  max_length <- max(lengths(arguments))
  args <- lapply(arguments, function(x, max_len) {
    length(x) <- max_length
    return(x)
  }, max_len = max_length)
  return(args)
}
```
## Create Data Frame
1. Pad vectors passed to the function
2. Create the data frame and set the column names
3. Transform and 'melt' the dataframe
```{r echo=TRUE}
create_data_frame <-function(car_names, ...) {
  car_data <- list(...)

  padded_fuel <- do.call(pad_lengths, car_data)
  car_frame <- data.frame(padded_fuel)
  colnames(car_frame) <- car_names
  
  car_frame.m <- melt(t(car_frame), id.vars="Cars", 
                                    value.name ="Fuel",
                                    variable.name = "Time")
  colnames(car_frame.m) <- c('Cars', 'Time', 'Fuel')
  return(car_frame.m)
}
```

## Using the functions
- You now have some functions
- These can be used, shared and adapted
    - Reduced risk of side effects
```{r echo=TRUE}
jazz_fuel_hist <- drive_car(100, 7.5, 10)

golf_fuel_hist <- drive_car(100, 2, 10)
golf_fuel_hist <- c(golf_fuel_hist,
                    drive_car(golf_fuel_hist[length(golf_fuel_hist)],
                              5, 10))

punto_fuel_hist <- drive_car(100, 10, 20)
punto_fuel_hist <- refuel_car(punto_fuel_hist, 70)
punto_fuel_hist <- c(punto_fuel_hist, drive_car(70, 10, 20))

```

## Using the functions
```{r echo=TRUE}
car_data_frame <- create_data_frame(car_names = c('Punto',
                                                  'Golf',
                                                  'Jazz'),
                                   punto_fuel_hist,
                                   golf_fuel_hist,
                                   jazz_fuel_hist)
 
fuel_line_plot <-ggplot(car_data_frame, aes(x = Time,
                                            y = Fuel,
                                            group  = Cars,
                                            colour = Cars)) +   
  geom_line() + geom_point()
```

## The resulting plot
```{r echo = FALSE, fig.keep=carplot, warning=FALSE,message=FALSE,error=FALSE}
fuel_line_plot
```


## This Isn't Perfect

- There is always way to improve Code
- The Drive function could be adapted
    - allow the user to pass a function that determines fuel usage
    - means it doesn't have to be a fixed linear usage
- The data is still being acted upon by functions
    - they could be grouped and protected further
    
